#!/usr/bin/env node
/**
 * @file dev-server.js
 * @description PM2 기반 개발 서버 관리자
 *
 * Relay, Pylon, Client (Vite): 모두 PM2로 관리
 *
 * 명령어:
 *   node scripts/dev-server.js start   - 서버 시작
 *   node scripts/dev-server.js stop    - 서버 종료
 *   node scripts/dev-server.js status  - 상태 확인
 *   node scripts/dev-server.js restart - 재시작
 *   node scripts/dev-server.js logs    - 로그 보기
 */

import { spawn } from 'child_process';
import { homedir } from 'os';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = join(__dirname, '..');
const configPath = join(rootDir, 'config', 'environments.json');
const ecosystemPath = join(rootDir, 'ecosystem.dev.config.cjs');

// 환경 설정 로드
const envConfig = JSON.parse(readFileSync(configPath, 'utf-8'));
const devConfig = envConfig.dev;

// PM2 프로세스 이름 목록
const pm2Names = [
  devConfig.relay.pm2Name,
  devConfig.pylon.pm2Name,
  devConfig.client.pm2Name,
];

/**
 * ~ 경로를 홈 디렉토리로 확장
 */
function expandPath(p) {
  if (p.startsWith('~/') || p === '~') {
    return join(homedir(), p.slice(1));
  }
  return p;
}

/**
 * ecosystem.dev.config.cjs 생성 (Relay + Pylon + Client)
 */
function generateEcosystem() {
  const configDir = expandPath(devConfig.pylon.configDir);
  const credentialsBackupDir = expandPath(devConfig.pylon.credentialsBackupDir);
  const dataDir = join(rootDir, devConfig.pylon.dataDir || 'dev-data');

  // 데이터 디렉토리 생성
  if (!existsSync(dataDir)) {
    mkdirSync(dataDir, { recursive: true });
  }

  // ESTELLE_ENV_CONFIG JSON 생성
  const envConfigJson = JSON.stringify({
    envId: devConfig.envId,
    pylon: {
      deviceId: devConfig.pylon.deviceId,
      relayUrl: devConfig.pylon.relayUrl,
      configDir: configDir,
      credentialsBackupDir: credentialsBackupDir,
      dataDir: dataDir,
      mcpPort: devConfig.pylon.mcpPort,
    },
  });

  const clientDir = join(rootDir, 'packages', 'client');

  const content = `// Auto-generated by dev-server.js
module.exports = {
  apps: [
    {
      name: '${devConfig.relay.pm2Name}',
      script: 'packages/relay/dist/bin.js',
      cwd: '${rootDir.replace(/\\/g, '\\\\')}',
      watch: false,
      autorestart: true,
      env: {
        NODE_ENV: 'development',
        PORT: '${devConfig.relay.port}',
        ENV_ID: '${devConfig.envId}'
      }
    },
    {
      name: '${devConfig.pylon.pm2Name}',
      script: 'packages/pylon/dist/bin.js',
      cwd: '${rootDir.replace(/\\/g, '\\\\')}',
      watch: false,
      autorestart: true,
      env: {
        NODE_ENV: 'development',
        ESTELLE_ENV_CONFIG: ${JSON.stringify(envConfigJson)}
      }
    },
    {
      name: '${devConfig.client.pm2Name}',
      script: '${join(rootDir, 'node_modules/vite/bin/vite.js').replace(/\\/g, '\\\\')}',
      cwd: '${clientDir.replace(/\\/g, '\\\\')}',
      args: '--port ${devConfig.client.port} --host',
      watch: false,
      autorestart: false,
      env: {
        NODE_ENV: 'development',
        VITE_GOOGLE_CLIENT_ID: ''
      }
    }
  ]
};
`;

  writeFileSync(ecosystemPath, content, 'utf-8');
  console.log(`[dev] Generated ${ecosystemPath}`);
}

/**
 * PM2 명령 실행
 */
function pm2(args, options = {}) {
  const result = spawn('pm2', args, {
    cwd: rootDir,
    stdio: options.silent ? 'pipe' : 'inherit',
    shell: true,
  });

  return new Promise((resolve, reject) => {
    let stdout = '';
    let stderr = '';

    if (options.silent) {
      result.stdout?.on('data', (data) => { stdout += data; });
      result.stderr?.on('data', (data) => { stderr += data; });
    }

    result.on('close', (code) => {
      if (code === 0 || options.ignoreError) {
        resolve({ stdout, stderr, code });
      } else {
        reject(new Error(`PM2 exited with code ${code}`));
      }
    });
  });
}

/**
 * PM2 프로세스 존재 여부 확인
 */
async function isPm2Running(name) {
  try {
    const result = await pm2(['describe', name], { silent: true, ignoreError: true });
    return result.code === 0 && !result.stderr.includes('not found');
  } catch {
    return false;
  }
}

// ============================================================================
// 명령어
// ============================================================================

async function start() {
  // 이미 실행 중인 서비스 확인
  const runningNames = [];
  for (const name of pm2Names) {
    if (await isPm2Running(name)) {
      runningNames.push(name);
    }
  }

  if (runningNames.length > 0) {
    console.log(`[dev] Already running: ${runningNames.join(', ')}`);
    console.log('[dev] Use "pnpm dev:restart" to restart.');
    return;
  }

  console.log('');
  console.log('========================================');
  console.log('  Estelle v2 Development Server');
  console.log('========================================');
  console.log('');
  console.log(`  Relay:  ws://localhost:${devConfig.relay.port}`);
  console.log(`  Pylon:  ${devConfig.pylon.relayUrl} (relay connection)`);
  console.log(`  Client: http://localhost:${devConfig.client.port}`);
  console.log('');
  console.log('  Logs:   pnpm dev:logs');
  console.log('  Stop:   pnpm dev:stop');
  console.log('');
  console.log('========================================');
  console.log('');

  // version.json 생성 (dev 환경)
  const versionJsonPath = join(rootDir, 'packages', 'relay', 'public', 'version.json');
  const relayPublicDir = join(rootDir, 'packages', 'relay', 'public');
  if (!existsSync(relayPublicDir)) {
    mkdirSync(relayPublicDir, { recursive: true });
  }
  writeFileSync(versionJsonPath, JSON.stringify({ env: 'dev', version: '', buildTime: new Date().toISOString() }), 'utf-8');
  console.log('[dev] Generated version.json');

  // ecosystem 생성
  generateEcosystem();

  // PM2로 전체 서비스 시작
  console.log('[dev] Starting all services with PM2...');
  await pm2(['start', ecosystemPath]);

  console.log('');
  console.log('[dev] All services started.');
}

async function stop() {
  console.log('[dev] Stopping dev server...');

  for (const name of pm2Names) {
    if (await isPm2Running(name)) {
      console.log(`[dev] Stopping ${name}...`);
      await pm2(['delete', name], { ignoreError: true });
    }
  }

  console.log('[dev] Server stopped.');
}

async function status() {
  console.log('[dev] Server status:');

  for (const name of pm2Names) {
    const running = await isPm2Running(name);
    const statusText = running ? '✅ running' : '❌ stopped';
    console.log(`  ${name}: ${statusText}`);
  }
}

async function restart() {
  await stop();
  await new Promise(r => setTimeout(r, 1000));
  await start();
}

async function logs() {
  const running = [];
  for (const name of pm2Names) {
    if (await isPm2Running(name)) {
      running.push(name);
    }
  }

  if (running.length === 0) {
    console.log('[dev] No services running.');
    return;
  }

  console.log('[dev] Showing logs for:', running.join(', '));
  console.log('[dev] Press Ctrl+C to exit');
  console.log('');

  await pm2(['logs', ...running, '--lines', '50']);
}

// ============================================================================
// 메인
// ============================================================================

const command = process.argv[2] || 'start';

switch (command) {
  case 'start':
    start();
    break;
  case 'stop':
    stop();
    break;
  case 'status':
    status();
    break;
  case 'restart':
    restart();
    break;
  case 'logs':
    logs();
    break;
  default:
    console.log('Usage: node scripts/dev-server.js [start|stop|status|restart|logs]');
    process.exit(1);
}
