#!/usr/bin/env node
/**
 * @file dev-server.js
 * @description PM2 + PowerShell 기반 개발 서버 관리자
 *
 * Relay, Pylon: PM2로 관리
 * Client (Vite): PowerShell 백그라운드 프로세스로 관리
 *
 * 명령어:
 *   node scripts/dev-server.js start   - 서버 시작
 *   node scripts/dev-server.js stop    - 서버 종료
 *   node scripts/dev-server.js status  - 상태 확인
 *   node scripts/dev-server.js restart - 재시작
 *   node scripts/dev-server.js logs    - 로그 보기
 */

import { spawn, exec } from 'child_process';
import { homedir } from 'os';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { readFileSync, writeFileSync, existsSync, mkdirSync, unlinkSync } from 'fs';

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = join(__dirname, '..');
const configPath = join(rootDir, 'config', 'environments.json');
const ecosystemPath = join(rootDir, 'ecosystem.dev.config.cjs');
const clientPidFile = join(rootDir, '.dev-client.pid');

// 환경 설정 로드
const envConfig = JSON.parse(readFileSync(configPath, 'utf-8'));
const devConfig = envConfig.dev;

/**
 * ~ 경로를 홈 디렉토리로 확장
 */
function expandPath(p) {
  if (p.startsWith('~/') || p === '~') {
    return join(homedir(), p.slice(1));
  }
  return p;
}

/**
 * ecosystem.dev.config.cjs 생성 (Relay + Pylon만)
 */
function generateEcosystem() {
  const configDir = expandPath(devConfig.pylon.configDir);
  const credentialsBackupDir = expandPath(devConfig.pylon.credentialsBackupDir);
  const dataDir = join(rootDir, devConfig.pylon.dataDir || 'dev-data');

  // 데이터 디렉토리 생성
  if (!existsSync(dataDir)) {
    mkdirSync(dataDir, { recursive: true });
  }

  // ESTELLE_ENV_CONFIG JSON 생성
  const envConfigJson = JSON.stringify({
    envId: devConfig.envId,
    pylon: {
      deviceId: devConfig.pylon.deviceId,
      relayUrl: devConfig.pylon.relayUrl,
      configDir: configDir,
      credentialsBackupDir: credentialsBackupDir,
      dataDir: dataDir,
      mcpPort: devConfig.pylon.mcpPort,
    },
    beacon: devConfig.beacon,
  });

  const content = `// Auto-generated by dev-server.js
module.exports = {
  apps: [
    {
      name: '${devConfig.relay.pm2Name}',
      script: 'packages/relay/dist/bin.js',
      cwd: '${rootDir.replace(/\\/g, '\\\\')}',
      watch: false,
      autorestart: true,
      env: {
        NODE_ENV: 'development',
        PORT: '${devConfig.relay.port}'
      }
    },
    {
      name: '${devConfig.pylon.pm2Name}',
      script: 'packages/pylon/dist/bin.js',
      cwd: '${rootDir.replace(/\\/g, '\\\\')}',
      watch: false,
      autorestart: true,
      env: {
        NODE_ENV: 'development',
        ESTELLE_ENV_CONFIG: ${JSON.stringify(envConfigJson)}
      }
    }
  ]
};
`;

  writeFileSync(ecosystemPath, content, 'utf-8');
  console.log(`[dev] Generated ${ecosystemPath}`);
}

/**
 * PM2 명령 실행
 */
function pm2(args, options = {}) {
  const result = spawn('pm2', args, {
    cwd: rootDir,
    stdio: options.silent ? 'pipe' : 'inherit',
    shell: true,
  });

  return new Promise((resolve, reject) => {
    let stdout = '';
    let stderr = '';

    if (options.silent) {
      result.stdout?.on('data', (data) => { stdout += data; });
      result.stderr?.on('data', (data) => { stderr += data; });
    }

    result.on('close', (code) => {
      if (code === 0 || options.ignoreError) {
        resolve({ stdout, stderr, code });
      } else {
        reject(new Error(`PM2 exited with code ${code}`));
      }
    });
  });
}

/**
 * PM2 프로세스 존재 여부 확인
 */
async function isPm2Running(name) {
  try {
    const result = await pm2(['describe', name], { silent: true, ignoreError: true });
    return result.code === 0 && !result.stderr.includes('not found');
  } catch {
    return false;
  }
}

/**
 * 포트로 PID 찾기
 */
function findPidByPort(port) {
  return new Promise((resolve) => {
    exec(`netstat -ano | findstr "LISTENING" | findstr ":${port} "`, (err, stdout) => {
      if (err || !stdout) {
        resolve(null);
        return;
      }
      const match = stdout.trim().split('\n')[0]?.match(/\s+(\d+)\s*$/);
      resolve(match ? parseInt(match[1], 10) : null);
    });
  });
}

/**
 * 프로세스 종료
 */
function killProcess(pid) {
  return new Promise((resolve) => {
    exec(`taskkill /PID ${pid} /F /T`, (err) => {
      resolve(!err);
    });
  });
}

/**
 * Vite 클라이언트 시작 (PowerShell 백그라운드)
 */
async function startClient() {
  const clientDir = join(rootDir, 'packages', 'client');
  const vitePath = join(rootDir, 'node_modules', 'vite', 'bin', 'vite.js');
  const port = devConfig.client.port;

  // 이미 실행 중인지 확인
  const existingPid = await findPidByPort(port);
  if (existingPid) {
    console.log(`[dev] Client already running on port ${port} (PID: ${existingPid})`);
    return;
  }

  // PowerShell로 백그라운드 실행
  const psCommand = `Start-Process -NoNewWindow -FilePath 'node' -ArgumentList '${vitePath}','--port','${port}','--host' -WorkingDirectory '${clientDir}'`;

  return new Promise((resolve, reject) => {
    exec(`powershell -Command "${psCommand}"`, (err) => {
      if (err) {
        reject(err);
      } else {
        // PID 찾아서 저장
        setTimeout(async () => {
          const pid = await findPidByPort(port);
          if (pid) {
            writeFileSync(clientPidFile, String(pid));
            console.log(`[dev] Client started on port ${port} (PID: ${pid})`);
          }
          resolve();
        }, 2000);
      }
    });
  });
}

/**
 * Vite 클라이언트 종료
 */
async function stopClient() {
  const port = devConfig.client.port;
  const pid = await findPidByPort(port);

  if (pid) {
    console.log(`[dev] Stopping client (PID: ${pid})...`);
    await killProcess(pid);
  }

  // PID 파일 삭제
  if (existsSync(clientPidFile)) {
    unlinkSync(clientPidFile);
  }
}

/**
 * 클라이언트 상태 확인
 */
async function isClientRunning() {
  const port = devConfig.client.port;
  const pid = await findPidByPort(port);
  return pid !== null;
}

// ============================================================================
// 명령어
// ============================================================================

async function start() {
  const pm2Names = [
    devConfig.relay.pm2Name,
    devConfig.pylon.pm2Name,
  ];

  // PM2 프로세스 확인
  for (const name of pm2Names) {
    if (await isPm2Running(name)) {
      console.log(`[dev] ${name} is already running. Use "pnpm dev:restart" to restart.`);
      return;
    }
  }

  // 클라이언트 확인
  if (await isClientRunning()) {
    console.log(`[dev] Client is already running. Use "pnpm dev:restart" to restart.`);
    return;
  }

  console.log('');
  console.log('========================================');
  console.log('  Estelle v2 Development Server');
  console.log('========================================');
  console.log('');
  console.log(`  Relay:  ws://localhost:${devConfig.relay.port}`);
  console.log(`  Pylon:  ${devConfig.pylon.relayUrl} (relay connection)`);
  console.log(`  Client: http://localhost:${devConfig.client.port}`);
  console.log('');
  console.log('  Logs:   pnpm dev:logs');
  console.log('  Stop:   pnpm dev:stop');
  console.log('');
  console.log('========================================');
  console.log('');

  // ecosystem 생성
  generateEcosystem();

  // PM2로 Relay + Pylon 시작
  console.log('[dev] Starting Relay and Pylon with PM2...');
  await pm2(['start', ecosystemPath]);

  // Vite 클라이언트 시작
  console.log('[dev] Starting Client...');
  await startClient();

  console.log('');
  console.log('[dev] All services started.');
}

async function stop() {
  const pm2Names = [
    devConfig.relay.pm2Name,
    devConfig.pylon.pm2Name,
  ];

  console.log('[dev] Stopping dev server...');

  // PM2 프로세스 종료
  for (const name of pm2Names) {
    if (await isPm2Running(name)) {
      console.log(`[dev] Stopping ${name}...`);
      await pm2(['delete', name], { ignoreError: true });
    }
  }

  // 클라이언트 종료
  await stopClient();

  console.log('[dev] Server stopped.');
}

async function status() {
  const pm2Names = [
    devConfig.relay.pm2Name,
    devConfig.pylon.pm2Name,
  ];

  console.log('[dev] Server status:');

  // PM2 상태
  for (const name of pm2Names) {
    const running = await isPm2Running(name);
    const statusText = running ? '✅ running' : '❌ stopped';
    console.log(`  ${name}: ${statusText}`);
  }

  // 클라이언트 상태
  const clientRunning = await isClientRunning();
  const clientStatus = clientRunning ? '✅ running' : '❌ stopped';
  console.log(`  ${devConfig.client.pm2Name}: ${clientStatus}`);
}

async function restart() {
  await stop();
  await new Promise(r => setTimeout(r, 1000));
  await start();
}

async function logs() {
  const pm2Names = [
    devConfig.relay.pm2Name,
    devConfig.pylon.pm2Name,
  ];

  // 실행 중인 PM2 프로세스 로그 표시
  const running = [];
  for (const name of pm2Names) {
    if (await isPm2Running(name)) {
      running.push(name);
    }
  }

  if (running.length === 0) {
    console.log('[dev] No PM2 services running.');
    return;
  }

  console.log('[dev] Showing logs for:', running.join(', '));
  console.log('[dev] (Client logs are in terminal output)');
  console.log('[dev] Press Ctrl+C to exit');
  console.log('');

  await pm2(['logs', ...running, '--lines', '50']);
}

// ============================================================================
// 메인
// ============================================================================

const command = process.argv[2] || 'start';

switch (command) {
  case 'start':
    start();
    break;
  case 'stop':
    stop();
    break;
  case 'status':
    status();
    break;
  case 'restart':
    restart();
    break;
  case 'logs':
    logs();
    break;
  default:
    console.log('Usage: node scripts/dev-server.js [start|stop|status|restart|logs]');
    process.exit(1);
}
