# Claude Code 세션의 특징과 한계

## 개요

Claude Code 세션 운용 시 발생하는 구조적 문제와 대응 전략을 정리한 문서.
주로 컨텍스트 압축(컴팩트)으로 인한 기억 소실, 세션별 편향, 그리고 이를 완화하기 위한 설계 패턴을 다룬다.

---

## 1. 컴팩트 (컨텍스트 압축)

### 현상

- Claude Code는 컨텍스트 윈도우 한계에 도달하면 이전 대화를 자동으로 압축(compact)한다.
- **AI 본인은 컴팩트가 일어났는지 인지하지 못한다.** 압축된 요약을 원본과 구분할 수 없다.
- 여러 번의 컴팩트가 누적되면 정보 손실이 가속된다 (요약의 요약의 요약...).

### 증상

| 증상 | 설명 |
|------|------|
| 말투 변화 | 페르소나(스텔라) 설정이 흐려져 딱딱한 어조로 바뀜 |
| 규칙 무시 | CLAUDE.md에 명시된 프로젝트 컨벤션을 따르지 않음 |
| 맥락 단절 | 이미 합의한 설계 결정을 다시 물어봄 |
| 반복 작업 | 이미 읽은 파일을 다시 읽거나, 같은 실수를 반복 |
| 자각 불가 | "컴팩트 됐지?"라고 물어도 "무슨 말씀이세요?" |

### 구조적 원인

```
[세션 시작]
  시스템 프롬프트: CLAUDE.md + MEMORY.md + git status
  ↓
[대화 진행] — 컨텍스트 축적
  ↓
[컨텍스트 한계 도달] — 자동 압축 (1차 컴팩트)
  ↓ 세부 정보 일부 손실
[대화 계속] — 컨텍스트 다시 축적
  ↓
[2차 컴팩트] — 1차 요약이 다시 압축됨
  ↓ 손실 가속
[n차 컴팩트] — 초기 맥락 대부분 소실
```

컴팩트가 반복될수록 **세션의 품질이 비가역적으로 저하**된다. 세션에는 일종의 "수명"이 있다.

### 불확실한 점

- 시스템 프롬프트(CLAUDE.md, MEMORY.md)가 컴팩트 대상인지, 매번 재주입되는지 명확하지 않음
- 경험적으로는 CLAUDE.md 내용도 잊어버리는 것이 관찰됨
- 압축 알고리즘이 무엇을 보존하고 무엇을 버리는지 블랙박스

---

## 2. 세션별 편향

### 현상

- 같은 CLAUDE.md, 같은 프로젝트에서도 세션마다 다른 "성격"이나 "고집"이 형성된다.
- 특정 구현 방식에 집착하거나, 방향 전환 지시를 받아도 원래 방향으로 돌아가려는 경향.

### 원인 분석

1. **초기 대화의 앵커링** — 세션 초반에 다룬 주제가 이후 응답 경향을 결정. 리팩토링 이야기를 많이 하면 뭘 봐도 리팩토링하고 싶어짐.
2. **확률적 분기** — 동일 입력에도 매번 다른 출력이 가능. 초기 분기가 세션 전체의 톤을 결정.
3. **자기 강화** — 한번 방향이 정해지면 이전 자기 응답을 참조하여 같은 방향을 유지. 컴팩트 시 이 편향이 요약에 반영되면 더 강화됨.
4. **컴팩트와의 상호작용** — 압축 과정에서 특정 맥락이 강조되면 편향이 고착화됨.

### TDD에서의 구체적 문제

단일 세션에서 TDD 전 과정을 수행하면:

```
테스트 작성 시 → 이미 구현 방법을 머릿속에 정해버림
  ↓
테스트가 구현을 검증하는 게 아니라, 구현에 맞춰 작성됨
  ↓
구현 중 테스트가 불편하면 → 테스트를 슬쩍 수정하고 싶어짐
  ↓
"내가 쓴 코드"라는 편향 → 객관적 검증 불가
```

이는 사람에게서도 나타나는 현상 — 코드 작성자와 리뷰어가 같으면 안 되는 이유와 동일.

---

## 3. 대응 전략

### 3.1 서브에이전트 분리

**목적**: 편향 격리 + 컨텍스트 절약 (일석이조)

서브에이전트(Task)는 메인 세션과 **별도의 컨텍스트**에서 실행된다.

- 무거운 작업을 서브에이전트에 위임 → 메인 세션 컨텍스트가 가벼워짐 → 컴팩트 지연
- 역할이 다른 작업을 분리 → 편향 격리 (TDD: 테스트 작성자 ≠ 구현자)
- 서브에이전트는 결과만 반환하므로, 과정에서 쌓인 편향이 메인 세션에 전이되지 않음

**적용 사례**: tdd-flow 스킬 — Plan / Test / Verify / Impl / Refactor를 각각 별도 에이전트로 실행

### 3.2 Linked Document (계획 중)

**목적**: 대화 본문을 짧게 유지하면서 필요한 정보 접근성 보존

- 긴 문서 내용을 대화에 직접 포함하면 컨텍스트를 빠르게 소모
- 대신 "이 문서를 참고해"라고 경로만 전달 → 필요할 때 Read로 읽기
- 매 턴마다 경로가 주입되므로, 컴팩트 이후에도 문서 접근 가능

### 3.3 외부 기억 장치

**목적**: 컴팩트/세션 경계를 넘어 정보 보존

| 장치 | 지속성 | 용량 | 용도 |
|------|--------|------|------|
| CLAUDE.md | 영구 (git) | 제한 없음 | 프로젝트 규칙, 컨벤션 |
| MEMORY.md | 영구 (로컬) | 200줄 | 세션 간 학습 메모 |
| wip/ 문서 | 영구 (git) | 제한 없음 | 작업 계획, 설계 문서 |
| 대화 컨텍스트 | 휘발성 | 윈도우 한계 | 현재 작업 맥락 |

MEMORY.md의 한계:
- 자동 정리 안 됨 — AI가 판단해서 수동으로 갱신해야 함
- 컴팩트 이후 "이 메모가 낡았다"는 인식 자체가 없을 수 있음
- 결국 사용자가 가끔 점검/지시해줘야 제대로 관리됨

### 3.4 세션 수명 관리

세션은 무한히 이어가는 것보다, **적절한 시점에 끊고 새로 시작**하는 것이 품질 유지에 유리하다.

- 하나의 작업 단위가 끝나면 새 세션 시작 고려
- 컴팩트가 2회 이상 발생한 것 같으면 (말투 변화, 규칙 무시 등 증상) 세션 교체 고려
- `/clear`로 대화를 리셋해도 같은 프로세스 내이므로 완전한 초기화인지는 불확실

---

## 4. 추가 고찰

### 세션 = 소모품

세션은 재사용 가능한 자원이 아니라 **소모품**에 가깝다. 사용할수록 품질이 저하되고, 복원할 수 없다. 따라서:

- 중요한 결정/합의는 세션 내에 두지 말고 **외부에 기록**
- 세션이 길어질수록 AI의 응답 품질을 신뢰하기 어려워짐
- "이 세션에서 계속 하자"보다 "여기까지 정리하고 새로 시작하자"가 더 안전

### AI의 자기 인식 한계

컴팩트, 편향 모두 AI 본인이 인지하기 어렵다는 것이 핵심 문제.

- 컴팩트: 일어났는지 모름
- 편향: 자기 응답이 편향되었는지 판단할 기준이 없음
- MEMORY.md 관리: 뭘 잊었는지 모르니 뭘 기록해야 하는지도 모름

결국 **사용자의 모니터링과 개입**이 필수적이다. AI가 자율적으로 세션 품질을 유지하는 것에는 구조적 한계가 있다.

### 대화 설계의 방향

이상적인 대화 패턴:
```
[짧은 지시] → [서브에이전트 위임] → [결과 확인] → [짧은 피드백]
```

피해야 할 패턴:
```
[긴 논의] → [긴 구현] → [긴 디버깅] → [컴팩트] → [맥락 상실] → [처음부터]
```

---

## TODO

- [ ] 컴팩트 시 시스템 프롬프트 재주입 여부 확인 (실험 필요)
- [ ] `/clear` vs 새 세션의 실질적 차이 확인
- [ ] MEMORY.md 자동 갱신 전략 고민
- [ ] 세션 "건강도" 지표를 만들 수 있는지 검토
